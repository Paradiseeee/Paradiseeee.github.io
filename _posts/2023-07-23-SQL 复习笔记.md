---
layout:         post
title:          "SQL 复习笔记"
subtitle:       "知识点复习补充"
date:           "2023-07-23 12:00:00"
author:         "Paradise"
header-style:   text
tags:
    - MySQL
    - 数据库
    - 编程语言
    - 数据分析
    - 笔记
---


## 函数和关键字


|用法|说明|
|:---|:---|
|round(x, n)|四舍五入，x为浮点数，n为保留的位数|
|ceil(x)|向上取整|
|floor(x)|向下取整|
|truncate(x, n)|截断x，n为保留的位，该位之后的数值置零，位数表示示例：321.123，其中小数点前用负值表示，小数点位数为0，即 truncate(x, 0) 等同于舍弃小数部分取整|
|mod(a, b)|返回 a 除以 b 的余数|
|abs(x)|返回 x 的绝对值|
|rand()|返回 0-1 的随机浮点数|
|sign(x)|返回数值的符号，1、-1或者0|
|avg(column)|返回字段或数组切片的均值|
|var_pop(column)|返回字段或数组切片的总体方差|
|var_samp(column)|返回字段或数组切片的样本方差（计算方法不同）|
|std(column)|总体标准差|
|stddev_samp(column)|样本标准差|
|replace(str, a, b)|将字符串中的 a 替换为 b(从头开始检索，替换所有存在的片段)|
|concat(a, b)|合并字符串（不能直接 a + b）（接受多个参数，按顺序合并）|
|concat_ws(fill, a, b)|合并并在两者之间填充 fill 片段|
|left(str, n) / right(str, n)|左起 / 右起取 n 个字符|
|substring(str, x, n)|左起 x 位（含）取 n 个字符|
|ltrim / rtrim / trim(str)|去除 左 / 右 / 两边的空格|
|repeat(str, n)|重复 n 次|
|char_length(str) / length(str)|返回字符数 / 字节数（mysql 中中文字符默认 3 字节）|
|coalesce(column, value)|使用 value 填充字段 column 中的空值|
|cast(column as dtype)|将 column 字段的数据类型转换为 dtype（如 char）|
|convert(column, dtype)|同上|
|now()|返回当前的年月日时分秒，默认格式为"%Y-%m-%d %h:%i:%s"|
|year/month/day/hour/minute/second(x)|依次返回 x 中包含的年/月/日/时/分/秒|
|date(time)/time(x)|返回 x 中的日期/时间|
|weekofyear(x)/dayofweek(x)|顾名思义，注意每周以周日为第 0 天，周一为第 1 天|
|date_format(x, format)|format 可以是 "%Y-%m-%d"，或者"%w"（返回周几）|
|date_add/date_sub(x, interval n unit)|x前移或后移一段时间，n 为数值，unit 为 year、month、day 等关键字|
|date_diff(a, b)|两个时间日期的差值|
|select * INTO OUTFILE filename from tablename;|输出到文件，默认在安装目录的 Data 文件夹|
|select * from tablename LIMIT n, m|从 n 行开始（含）取 m 行|
|select ... where column LIKE "%str%"|匹配字符串，用 % 表示任意数量的任意字符，用 - 表示单个任意字符|
|select ... where column REGEXP "regexp"|类似 LIKE，使用正则表达式，更精准的匹配|
|select ... IF(condition, true_value, false_value) from table|条件赋值|
|select ... CASE WHEN condition1 THEN value1 WHEN condition2 THEN value2 ... ELSE last_value END from table|多个条件匹配赋值|

<hr />

![速查表](/post-assets/20230723/sqlCheatSheet.png)

## 示例与习题

```sql
/* Employee */
-- +----+-------+--------+--------------+
-- | Id | Name  | Salary | DepartmentId |
-- +----+-------+--------+--------------+
-- | 1  | Joe   | 70000  | 1            |
-- | 2  | Henry | 80000  | 2            |
-- | 3  | Sam   | 60000  | 2            |
-- | 4  | Max   | 90000  | 1            |
-- +----+-------+--------+--------------+

/* Department */
-- +----+----------+
-- | Id | Name     |
-- +----+----------+
-- | 1  | IT       |
-- | 2  | Sales    |
-- +----+----------+

/* result */
-- +------------+----------+--------+
-- | Department | Employee | Salary |
-- +------------+----------+--------+
-- | IT         | Max      | 90000  |
-- | Sales      | Henry    | 80000  |
-- +------------+----------+--------+

/* 最直接的思路就是一层一层的嵌套子查询了，但是可读性一般 */
SELECT 
    DName AS Department,
    Name AS Employee,
    Salary
FROM (
    SELECT 
        Name, DName, Salary,
        RANK() OVER (PARTITION BY DName ORDER BY Salary DESC) as Ranking
    FROM (
        SELECT * FROM Employee 
        INNER JOIN 
        (SELECT Name AS Dname, Id AS DId FROM Department)
        AS d 
        ON d.DId = Employee.departmentId
    ) as joined
)
AS ranked
WHERE ranked.Ranking = 1;
```

```sql
/* 来自 <https://github.com/datawhalechina/team-learning-sql/blob/main/Task06%EF%BC%9A%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.md> 的题目 */

/* Answer 01 */

WITH t2 AS (
	WITH t1 AS(
		SELECT 
		a.Name AS Employee,
		a.Salary AS Salary,
		b.Name AS Department
		FROM employee AS a JOIN department AS b
		WHERE a.DepartmentId = b.Id
	)
    SELECT 
	*, 
	RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS ranking
	FROM t1
)
SELECT 
Department, Employee, Salary
FROM t2
WHERE ranking = 1;

/* Answer 02 */

SELECT 
(
CASE
WHEN id <> (select count(id) from seat) AND mod(id, 2) <> 0 THEN id + 1
WHEN id <> (select count(id) from seat) AND mod(id, 2) = 0 THEN id - 1
ELSE id
END
) 
AS id,
student
FROM seat
ORDER BY id;

/* Answer 03*/

SELECT 
Score,
RANK() OVER(ORDER BY amount DESC) AS `Rank`
FROM Score;

/* Answer 04 */

SELECT DISTINCT(Num) AS ConsecutiveNums 
FROM 
(
	SELECT 
	*,
	lag(id, 2) OVER(PARTITION BY Num ORDER BY id) AS id_new 
	FROM logs
) AS A 
WHERE A.id = A.id_new + 2;

-- LAG 函数语法：
-- LAG(return_value ,offset [,default]) 
-- OVER (
--     [PARTITION BY partition_expression, ... ]
--     ORDER BY sort_expression [ASC | DESC], ...
-- )

/* Answer 05 */

SELECT id,
CASE
WHEN t.p_id IS NULL THEN 'Root' 
WHEN t.id IN(SELECT p_id FROM tree ) THEN 'Inner'
ELSE 'Leaf' 
END AS `Type`
FROM  tree t;

/* Answer 06 */

SELECT 
A.Name
FROM Employee AS A
LEFT JOIN Employee AS B
ON A.Id = B.ManagerId
GROUP BY A.Id
HAVING COUNT(*) >=  5
```